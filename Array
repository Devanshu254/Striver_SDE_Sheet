Q1. Link -> https://leetcode.com/problems/set-matrix-zeroes/
Solution -> https://takeuforward.org/data-structure/set-matrix-zero/

class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
        // calculating the row and column size.
        int n = matrix.size();
        int m = matrix[0].size();
        // creating an extra column.
        int col0 = 1;
        // Iterating the matrix and marking the hash rows and columns.
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(matrix[i][j] == 0){
                    matrix[i][0] = 0;
                    if(j!=0)
                        matrix[0][j] = 0;
                    else
                        col0 = 0;
                }
            }
        }
        for(int i=1;i<n;i++){
            for(int j=1;j<m;j++){
                if(matrix[i][j] != 0){
                    if(matrix[i][0] == 0 || matrix[0][j] == 0){
                        matrix[i][j] = 0;
                    }
                }
            }
        }
        if(matrix[0][0] == 0){
            for(int j=1;j<m;j++){
                matrix[0][j] = 0;
            }
        }
        if(col0 == 0){
            for(int i=0;i<n;i++){
                matrix[i][0] = 0;
            }
        }
    }
};

Q2. Pascals triangle
Solution ->
class Solution {
    vector<int> generateRow(int row){
        long long ans = 1;
        vector<int> ansRow;
        ansRow.push_back(1);
        for(int col = 1; col<row; col++){
            ans = ans * (row - col);
            ans = ans/(col);
            ansRow.push_back(ans);
        }
        return ansRow;
    }
public:
    vector<vector<int>> generate(int numRows) {
        vector<vector<int>> ans;
        for(int i=1;i<=numRows;i++){
            ans.push_back(generateRow(i));
        }
        return ans;
    }
};


Q3. Climbing stairs.
Solution -> 
class Solution {
public:
    int climbStairs(int n) {
        int prev = 1;
        int prev2 = 1;
        int curr;
        for(int i=2;i<=n;i++){
            curr = prev + prev2;
            prev2 = prev;
            prev = curr;
        }
        return prev;
    }
};

Q4. Binary tree inorder traversal.
Solution -> 

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> v;
        stack<TreeNode* > s;
        while(true){
            if(root != NULL){
                s.push(root);
                root = root->left;
            }else{
                if(s.empty() == true) break;
                root = s.top();
                v.push_back(root->val);
                s.pop();
                root = root->right;
            }
        }
        return v;
    }
};

Q5. Binary Tree preorder traversal.
Solution ->

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> v;
        if(root == NULL) return v;
        stack<TreeNode*> st;
        st.push(root);
        while(!st.empty()){
            TreeNode* top = st.top();
            v.push_back(top->val);
            st.pop();
            if(top->right != NULL) st.push(top->right);
            if(top->left != NULL) st.push(top->left);
        }
        return v;
    }
};

Q6. Binary tree inorder traversal.
Solution -> 

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> v;
        stack<TreeNode*> s;
        while(true){
            if(root != NULL){
                s.push(root);
                root = root->left;
            }else{
                if(s.empty() == true) break;
                root = s.top();
                v.push_back(root->val);
                s.pop();
                root = root->right;
            }
        }
        return v;
    }
};

Q7. Binary tree postorder traversal.
Solution -> 
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> v;
        if(root == NULL) return v;
        stack<TreeNode*> s1;
        stack<TreeNode*> s2;
        s1.push(root);
        while(!s1.empty()){
            root = s1.top();
            s1.pop();
            s2.push(root);
            if(root->left != NULL) s1.push(root->left);
            if(root->right != NULL) s1.push(root->right);
        }
        while(!s2.empty()){
            v.push_back(s2.top()->val);
            s2.pop();
        }
        return v;
    }
};

Q8. Next permutation.
Solution -> 
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int ind = -1;
        int n = nums.size();
        for(int i=n-2;i>=0;i--){
            if(nums[i]<nums[i+1]){
                ind = i;
                break;
            }
        }
        if(ind == -1){
            reverse(nums.begin(),nums.end());
        }else{
            for(int i=n-1;i>=0;i--){
                if(nums[i]>nums[ind]){
                    swap(nums[i],nums[ind]);
                    break;
                }
            }
            reverse(nums.begin()+ind+1, nums.end());
        }
    }
};

Q9. Maximum subarray - kadanes algorithm.
solution -> 
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int n = nums.size();
        long long maxi = INT_MIN;
        long long sum = 0;
        for(int i=0;i<n;i++){
            sum = sum + nums[i];
            if(sum > maxi) maxi = sum;
            if(sum < 0) sum = 0;
        }
        return maxi;
    }
};
