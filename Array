Q1. Link -> https://leetcode.com/problems/set-matrix-zeroes/
Solution -> https://takeuforward.org/data-structure/set-matrix-zero/

class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
        // calculating the row and column size.
        int n = matrix.size();
        int m = matrix[0].size();
        // creating an extra column.
        int col0 = 1;
        // Iterating the matrix and marking the hash rows and columns.
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(matrix[i][j] == 0){
                    matrix[i][0] = 0;
                    if(j!=0)
                        matrix[0][j] = 0;
                    else
                        col0 = 0;
                }
            }
        }
        for(int i=1;i<n;i++){
            for(int j=1;j<m;j++){
                if(matrix[i][j] != 0){
                    if(matrix[i][0] == 0 || matrix[0][j] == 0){
                        matrix[i][j] = 0;
                    }
                }
            }
        }
        if(matrix[0][0] == 0){
            for(int j=1;j<m;j++){
                matrix[0][j] = 0;
            }
        }
        if(col0 == 0){
            for(int i=0;i<n;i++){
                matrix[i][0] = 0;
            }
        }
    }
};

Q2. Pascals triangle
Solution ->
class Solution {
    vector<int> generateRow(int row){
        long long ans = 1;
        vector<int> ansRow;
        ansRow.push_back(1);
        for(int col = 1; col<row; col++){
            ans = ans * (row - col);
            ans = ans/(col);
            ansRow.push_back(ans);
        }
        return ansRow;
    }
public:
    vector<vector<int>> generate(int numRows) {
        vector<vector<int>> ans;
        for(int i=1;i<=numRows;i++){
            ans.push_back(generateRow(i));
        }
        return ans;
    }
};


Q3. Climbing stairs.
Solution -> 
class Solution {
public:
    int climbStairs(int n) {
        int prev = 1;
        int prev2 = 1;
        int curr;
        for(int i=2;i<=n;i++){
            curr = prev + prev2;
            prev2 = prev;
            prev = curr;
        }
        return prev;
    }
};

Q4. Binary tree inorder traversal.
Solution -> 

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> v;
        stack<TreeNode* > s;
        while(true){
            if(root != NULL){
                s.push(root);
                root = root->left;
            }else{
                if(s.empty() == true) break;
                root = s.top();
                v.push_back(root->val);
                s.pop();
                root = root->right;
            }
        }
        return v;
    }
};

Q5. Binary Tree preorder traversal.
Solution ->

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> v;
        if(root == NULL) return v;
        stack<TreeNode*> st;
        st.push(root);
        while(!st.empty()){
            TreeNode* top = st.top();
            v.push_back(top->val);
            st.pop();
            if(top->right != NULL) st.push(top->right);
            if(top->left != NULL) st.push(top->left);
        }
        return v;
    }
};

Q6. Binary tree inorder traversal.
Solution -> 

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> v;
        stack<TreeNode*> s;
        while(true){
            if(root != NULL){
                s.push(root);
                root = root->left;
            }else{
                if(s.empty() == true) break;
                root = s.top();
                v.push_back(root->val);
                s.pop();
                root = root->right;
            }
        }
        return v;
    }
};

Q7. Binary tree postorder traversal.
Solution -> 
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> v;
        if(root == NULL) return v;
        stack<TreeNode*> s1;
        stack<TreeNode*> s2;
        s1.push(root);
        while(!s1.empty()){
            root = s1.top();
            s1.pop();
            s2.push(root);
            if(root->left != NULL) s1.push(root->left);
            if(root->right != NULL) s1.push(root->right);
        }
        while(!s2.empty()){
            v.push_back(s2.top()->val);
            s2.pop();
        }
        return v;
    }
};

Q8. Next permutation.
Solution -> 
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int ind = -1;
        int n = nums.size();
        for(int i=n-2;i>=0;i--){
            if(nums[i]<nums[i+1]){
                ind = i;
                break;
            }
        }
        if(ind == -1){
            reverse(nums.begin(),nums.end());
        }else{
            for(int i=n-1;i>=0;i--){
                if(nums[i]>nums[ind]){
                    swap(nums[i],nums[ind]);
                    break;
                }
            }
            reverse(nums.begin()+ind+1, nums.end());
        }
    }
};

Q9. Maximum subarray - kadanes algorithm.
solution -> 
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int n = nums.size();
        long long maxi = INT_MIN;
        long long sum = 0;
        for(int i=0;i<n;i++){
            sum = sum + nums[i];
            if(sum > maxi) maxi = sum;
            if(sum < 0) sum = 0;
        }
        return maxi;
    }
};

Q10. Count inversions in an array.
Inversion is defined as traverse array from left to right and then compare its elements from i = 0 and j = n-1 such that arr[i] > arr[j].

#include <bits/stdc++.h> 
long long merge(long long *arr, long long low, long long mid, long long high){
    vector<int> temp;
    int left = low;
    int right = mid + 1;
    int count = 0;
    while(left <= mid && right <= high){
        if(arr[left] <= arr[right]){
            temp.push_back(arr[left]);
            left++;
        }else{
            temp.push_back(arr[right]);
            count = count+ (mid-left+1);
            right++;
        }
    }
    while(left <= mid){
        temp.push_back(arr[left]);
        left++;
    }
    while(right <= high){
        temp.push_back(arr[right]);
        right++;
    }
    for(int i=low; i<= high; i++){
        arr[i] = temp[i-low]; //This condition is different in merge sort.
    }
    return count;
}

long long mergeSort(long long *arr, long long low, long long high){
    long long count = 0;
    if(low >= high) return count;
    long long mid = (low+high)/2;
    count = count + mergeSort(arr, low, mid);
    count = count + mergeSort(arr, mid+1, high);
    count = count + merge(arr, low, mid, high);
    return count;
}

long long getInversions(long long *arr, int n){
    // Write your code here.
    return mergeSort(arr, 0, n-1);
}

Q12. Merge sort.
Solution -> 

void merge(int arr[], int l, int m, int r)
    {
         // Your code here
         vector<int> temp;
         int low = l;
         int high = m+1;
         while(low <= m && high <= r){
             if(arr[low] <= arr[high]){
                 temp.push_back(arr[low]);
                 low++;
             }else{
                 temp.push_back(arr[high]);
                 high++;
             }
         }
         while(low <= m){
             temp.push_back(arr[low]);
             low++;
         }
         while(high <= r){
             temp.push_back(arr[high]);
             high++;
         }
         for(int i=0;i<temp.size();i++){
             arr[l+i] = temp[i]; // This condition is different in code of inversion.
         }
    }
    public:
    void mergeSort(int arr[], int l, int r)
    {
        //code here
        if(l >= r){
            return;
        }
        int mid = (l+r)/2;
        mergeSort(arr, l, mid);
        mergeSort(arr, mid+1, r);
        merge(arr, l, mid, r);
    }
